var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/PixivIcon.ts
import warning from "warning";

// src/charcoalIconFiles.ts
import charcoalIconFiles from "@charcoal-ui/icon-files";
var charcoalIconFiles_default = charcoalIconFiles;
var KNOWN_ICON_FILES = Object.keys(
  charcoalIconFiles
);
function isKnownIconFile(name) {
  return name in charcoalIconFiles;
}

// src/loaders/PixivIconLoadError.ts
var PixivIconLoadError = class extends Error {
  constructor(name, cause) {
    const message = formatMessage(name, cause);
    super(message, { cause });
    this.name = "PixivIconLoadError";
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
function formatMessage(name, cause) {
  const message = `Failed to fetch <pixiv-icon name="${name}">`;
  if (cause == null) {
    return message;
  }
  if (cause instanceof Error) {
    return `${message}: ${cause.toString()})`;
  }
  return `${message}: ${JSON.stringify(cause)})`;
}

// src/loaders/CharcoalIconFilesLoader.ts
var CharcoalIconFilesLoader = class {
  _name;
  _resultSvg = void 0;
  _promise = void 0;
  constructor(name) {
    this._name = name;
  }
  get importIconFile() {
    return charcoalIconFiles_default[this._name];
  }
  async fetch() {
    if (this._resultSvg !== void 0) {
      return this._resultSvg;
    }
    if (this._promise) {
      return this._promise;
    }
    this._promise = this.importIconFile().then((svg) => {
      this._resultSvg = svg;
      return this._resultSvg;
    }).catch((e) => {
      throw new PixivIconLoadError(this._name, e);
    }).finally(() => {
      this._promise = void 0;
    });
    return this._promise;
  }
};

// src/loaders/CustomIconLoader.ts
var CustomIconLoader = class {
  _name;
  _filePathOrUrl;
  _resultSvg = void 0;
  _promise = void 0;
  constructor(name, filePathOrUrl) {
    this._name = name;
    this._filePathOrUrl = filePathOrUrl;
  }
  async fetch() {
    if (this._resultSvg !== void 0) {
      return this._resultSvg;
    }
    if (this._promise) {
      return this._promise;
    }
    this._promise = fetch(this._filePathOrUrl).then((response) => {
      if (!response.ok) {
        throw new PixivIconLoadError(this._name, "Response is not ok");
      }
      return response.text();
    }).then((svg) => {
      this._resultSvg = svg;
      return this._resultSvg;
    }).catch((e) => {
      if (e instanceof PixivIconLoadError) {
        throw e;
      }
      throw new PixivIconLoadError(this._name, e);
    }).finally(() => {
      this._promise = void 0;
    });
    return this._promise;
  }
};

// src/loaders/index.ts
var loaders = /* @__PURE__ */ new Map();
function addCustomIcon(name, filePathOrUrl) {
  loaders.set(name, new CustomIconLoader(name, filePathOrUrl));
}
async function getIcon(name) {
  const loader = resolveIconLoader(name);
  if (loader == null) {
    throw new PixivIconLoadError(name, "Loader was not found");
  }
  return loader.fetch().catch((e) => {
    if (e instanceof PixivIconLoadError) {
      throw e;
    }
    throw new PixivIconLoadError(name, e);
  });
}
function resolveIconLoader(name) {
  const registeredLoader = loaders.get(name);
  if (registeredLoader) {
    return registeredLoader;
  }
  if (isKnownIconFile(name)) {
    const charcoalIconFilesLoader = new CharcoalIconFilesLoader(name);
    loaders.set(name, charcoalIconFilesLoader);
    return charcoalIconFilesLoader;
  }
  return null;
}

// src/ssr.ts
var __SERVER__ = typeof window === "undefined";
var CAN_USE_DOM = typeof HTMLElement !== "undefined";
if (__SERVER__ || !CAN_USE_DOM) {
  globalThis.HTMLElement = class {
  };
}

// src/PixivIcon.ts
import DOMPurify from "dompurify";
var attributes = ["name", "scale", "unsafe-non-guideline-scale"];
var ROOT_MARGIN = 50;
var PixivIcon = class extends HTMLElement {
  static extend(map) {
    warning(!__SERVER__, "Using `PixivIcon.extend()` on server has no effect");
    if (__SERVER__) {
      return;
    }
    Object.entries(map).forEach(([name, filePathOrUrl]) => {
      if (!name.includes("/")) {
        throw new TypeError(
          `${name} is not a valid icon name. "name" must be named like [size]/[Name].`
        );
      }
      addCustomIcon(name, filePathOrUrl);
    });
  }
  static get observedAttributes() {
    return attributes;
  }
  svgContent;
  observer;
  isVisible = false;
  get props() {
    const partial = Object.fromEntries(
      attributes.map((attribute) => [attribute, this.getAttribute(attribute)])
    );
    const name = partial.name;
    if (name === null) {
      throw new TypeError('property "name" is required.');
    }
    if (!name.includes("/")) {
      throw new TypeError(
        `${name} is not a valid icon name. "name" must be named like [size]/[Name].`
      );
    }
    return {
      ...partial,
      name
    };
  }
  get forceResizedSize() {
    if (this.props["unsafe-non-guideline-scale"] === null) {
      return null;
    }
    const [size] = this.props.name.split("/");
    const scale = Number(this.props["unsafe-non-guideline-scale"]);
    switch (size) {
      case "Inline": {
        return 16 * scale;
      }
      default: {
        return Number(size) * scale;
      }
    }
  }
  get scaledSize() {
    const [size] = this.props.name.split("/");
    const scale = Number(this.props.scale ?? "1");
    switch (size) {
      case "Inline": {
        switch (scale) {
          case 2: {
            return 32;
          }
          default: {
            return 16;
          }
        }
      }
      case "24": {
        return Number(size) * scale;
      }
      default: {
        return Number(size);
      }
    }
  }
  constructor() {
    super();
    this.attachShadow({ mode: "open" });
  }
  async connectedCallback() {
    this.render();
    await this.waitUntilVisible();
    this.isVisible = true;
    await this.loadSvg(this.props.name);
  }
  disconnectedCallback() {
    this.observer?.disconnect();
    this.observer = void 0;
    this.isVisible = false;
  }
  attributeChangedCallback(attr, _oldValue, newValue) {
    if (!this.isVisible) {
      return;
    }
    if (attr === "name") {
      void this.loadSvg(newValue);
      return;
    }
    if (this.svgContent !== void 0) {
      this.render();
      return;
    }
    void this.loadSvg(this.props.name);
  }
  render() {
    const size = this.forceResizedSize ?? this.scaledSize;
    const style = DOMPurify.sanitize(
      `<style>
  :host {
    display: inline-flex;
    --size: ${size}px;
  }

  svg {
    width: var(--size);
    height: var(--size);
  }
</style>`,
      { ALLOWED_TAGS: ["style"], FORCE_BODY: true }
    );
    const svg = DOMPurify.sanitize(
      this.svgContent !== void 0 ? this.svgContent : `<svg viewBox="0 0 ${size} ${size}"></svg>`,
      { USE_PROFILES: { svg: true, svgFilters: true } }
    );
    this.shadowRoot.innerHTML = style + svg;
  }
  async loadSvg(name) {
    this.svgContent = await getIcon(name);
    this.render();
  }
  waitUntilVisible() {
    return new Promise((resolve) => {
      this.observer = new IntersectionObserver(
        ([first]) => {
          if (first.isIntersecting) {
            this.observer?.disconnect();
            this.observer = void 0;
            resolve();
          }
        },
        { rootMargin: `${ROOT_MARGIN}px` }
      );
      this.observer.observe(this);
    });
  }
};
__publicField(PixivIcon, "tagName", "pixiv-icon");

// src/index.ts
if (!__SERVER__) {
  if (!window.customElements.get(PixivIcon.tagName)) {
    window.PixivIcon = PixivIcon;
    window.customElements.define(PixivIcon.tagName, PixivIcon);
  }
}
export {
  KNOWN_ICON_FILES,
  PixivIcon,
  PixivIconLoadError
};
//# sourceMappingURL=index.esm.js.map